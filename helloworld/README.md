# Why do we learn Java

## What is Java

- C言語の場合os別にcompileをしなければならない, -> depends on OS -> 早い
- JavaはJVMの上で動くのでどこでも動く -> 遅い -> JVMの性能が向上されている
- OOP志向言語 -> 拡張性が良い
- OpenSource

## データの表現
<a href="https://github.com/const-takeo/learning-java/blob/main/helloworld/src/data/Dataexpression.java"> * -> </a>
- bit: 2進数一個の値をセーブできるメモリの大きさ→コンピュータが表現するデータの最小単位
- byte: 8bit

- 一番前が
- 0B -> 2進数を表す　-> 0B1010
- 0 -> 8進数 -> 012
- 0X -> 16進数 -> 0XA

- integerを表現する時一番良く使われているビット数は32ビット

### 負の整数の表現方法

- 整数の一番左側に存在するビットは符号ビット
  - MSB(Most Significant Bit)　一番重要なビット
  - 0 -> +
  - 1 -> -
- 負の整数を作る方法
  - 2の補数を取る
    - 1の補数をとって１を足す

## Variables

- Javaでの変数宣言し有意事項
  - 変数の名前はalphabet, numbers, _, $で構成される。
  - 大小文字を区別する。
  - 名前の間に空白があってはならない
  - 役割に相応しい名前にする事。
  - 変数の名前は数字で始められない -> 頭文字を数字にしてはならない

- 資料型
  - メモリを使うに当たって(変数を宣言する)使用するスペースの大きさと特性(型)に基づいて宣言する。

  - 整数型
    1. byte (1byte) : 動画や音楽などのファイルを処理する時使用する。
    2. short(2byte) : 主に C / C++ との互換のために使用する。
    3. int  (4byte) : javaでの基本資料型
    4. long (8byte) : 一番大きい資料型、数字の後ろに L or l -> 16L

  - 文字型
    1. char (2byte) : JavaはUnicode UTF-16を使用する。整数型intに変換して保存する

  - 実数型
    1. float (4byte) : float型を使うときは後ろにF, fを　付ける。
    2. double (8byte) : javaの基本実数型

  - 論理型
    1. boolean (1byte) : true or false;

  - 資料型なしに変数使用(java 10)
    - 資料型が必要な利用としては変数を宣言する時使用するメモリの大きさとタイプを区別するために使用
    - 地域変数タイプ推論(Local Variable Type Inference)　→　変数に体入する値を見てcompilerが推論して決める。


- 定数(constant)
  - 変化しない値
  - Javaでの定数の宣言 -> finalを使う -> goやjavascriptみたいにconst型がない
  - 定数の場合大文字で宣言するのがコンベンション(convention)


- Literal
  - Promgramで使われる全ての数字、値、論理値...
  - literalに当たる値は特定のメモリ空間に保存されている(constant pool)
  - 必要な場合constant poolから持ってきて使う
  - constant poolに保存される時整数はint型、実数はdoubleで保存されるのが基本ルール
  - よってlong,floatを使う場合識別子を明示しなければならない

- 型変換(type conversion)
  - 資料型は各々使うメモリ空間の大きさと方式が違う
  - 黙示的型変換(Implicit Conversion)
    - 小さい値から大きい値に、やや精密度が低いからもっと精密な値に体入される時
    - ex) `long num = 3; 3` <- literalとして基本int型
  - 明示的型変換(Explicit Conversion)
    - 黙示的型変換の反対
    - 変換される型を明示する必要がある、
    - 値の損失があり得る。

## Operator(演算子)
  - Operand(被演算子・항) : 演算に使用される値。
  - Operator(演算子・연산자) : 被演算子を利用して演算する記号
    - 単項演算子 : ```++num```
    - 二項演算子 : ```num1 + num2;```
    - 三項演算子 : ```(5>3) ? 1 : 0;```

  ### 代入演算子
  - 変数に値を代入する演算子
   - 優先順位が一番低い演算子
    

  ### 算術演算子
  - 四則演算に使われる
  - `+ - * / % `

  ### 増加減少演算子
  - `++`  被演算子の値に１を足す
    - `val = ++num;`
      - 先にnumの値が増加した後valに代入される。
      - -> ;(semi colon)が付けられる前に足せという意味;
    - `val = num++;`
      - valに既存のnumの値を代入した後numの値を増加させる
  - `--`  被演算子の値から１を引く

  ### 関係演算子
  - 二項演算し
    - 演算の結果がtrue、falseどちらかで変換される。
    - 左被演算子が基準
    - `>` ->  `num>3` : true
    - `<` ->  `num<3` : true
    - `>=` ->  `num>=3` : true
    - `<=` ->  `num<=3` : true
    - `==` ->  `num==3` : true
    - `!=` ->  `num!=3` : true

  ### 論理演算子
  - 関係演算子と交わってよく使われる
  - 演算の結果がtrue or falseどちらかで変換される。
  - `&&` 論理積：両被演算子がtrueの場合trueを返すそうでは無い場合false　`bool bVal = (5 > 3) && (5 > 2)` : true;
  - `||` 論理和：両被演算子の内一つだけtrueであればtrueを返す `bool bVal = (5 > 3) || (5 < 2)` : true;
  - `!` 単行演算子である、否定 trueはfalse、falseはtrue `bool bVal = !(5 > 3)` : false;
  - 短絡回廊評価(Short Circuit Evaluation)
    - 論理積(&&)は両被演算子が全てtrueの場合結果がtrueになる
      - &rarr; 前の被演算子がfalseであれば後ろの被演算子を評価しなくてもfalseである。
    - 論理和(||)は両被演算子が全てfalseの時結果がfalseになる
      - &rarr; 前の被演算子がtrueであれば後ろの被演算子を評価しなくてもtrueである。

  ### 複合代入演算子
  - 代入演算子と他の演算子を一緒に使う。
  - 実際のコーディングでよく使われる。

    - `+=`: 二つの被演算子の値を足して左の被演算子に代入 `num += 2;` == `num1 = num1 + 2;`
    - `-=`: 左の被演算子から右の被演算子の値を引いてそれを左の被演算子に足す `num -= 2;`
    - `*=`: 二つの値を掛けてその値を左被演算子に代入 `num *= 2;`
    - `/=`: ...
    - `%=`: ...

    ビット演算子との複合演算子
    - `<<=`: 
    - `>>=`: 
    - `>>>=`: 
    - `&=`: 
    - `!=`: 
    - `^=`: 

  ### 条件演算子
    - 三項演算子
      - 条件式の結果がtrueの場合とfalseの場合によって他の式や結果が実行される。
      `(5 > 3) ? trueSomething() : falseSomething();`


  ### ビット演算子
  - ビット演算子は整数のみ適用可能
    - `~`: ビットの反転（１の補数） `a = ~a`;
    - `&`: ビット単位AND 1&1 -> 1 その以外は0
    - `|`: ビット単位OR 0|0 -> 0 その以外は1
    - `^`: ビット単位XOR 二つのビットが違う場合1を返す一緒の時は0
    - `<<`: 左シフト `a << 2` 変数aを2ビット左にシフトさせる。
    - `>>`: 右シフト `a >> 2` 変数aを2ビット左にシフトさせる。
