# Why do we learn Java

## What is Java

- C言語の場合os別にcompileをしなければならない, -> depends on OS -> 早い
- JavaはJVMの上で動くのでどこでも動く -> 遅い -> JVMの性能が向上されている
- OOP志向言語 -> 拡張性が良い
- OpenSource

## データの表現
<a href="https://github.com/const-takeo/learning-java/blob/main/helloworld/src/data/Dataexpression.java"> * -> </a>
- bit: 2進数一個の値をセーブできるメモリの大きさ→コンピュータが表現するデータの最小単位
- byte: 8bit

- 一番前が
- 0B -> 2進数を表す　-> 0B1010
- 0 -> 8進数 -> 012
- 0X -> 16進数 -> 0XA

- integerを表現する時一番良く使われているビット数は32ビット

### 負の整数の表現方法

- 整数の一番左側に存在するビットは符号ビット
  - MSB(Most Significant Bit)　一番重要なビット
  - 0 -> +
  - 1 -> -
- 負の整数を作る方法
  - 2の補数を取る
    - 1の補数をとって１を足す

## Variables

- Javaでの変数宣言し有意事項
  - 変数の名前はalphabet, numbers, _, $で構成される。
  - 大小文字を区別する。
  - 名前の間に空白があってはならない
  - 役割に相応しい名前にする事。
  - 変数の名前は数字で始められない -> 頭文字を数字にしてはならない

- 資料型
  - メモリを使うに当たって(変数を宣言する)使用するスペースの大きさと特性(型)に基づいて宣言する。

  - 整数型
    1. byte (1byte) : 動画や音楽などのファイルを処理する時使用する。
    2. short(2byte) : 主に C / C++ との互換のために使用する。
    3. int  (4byte) : javaでの基本資料型
    4. long (8byte) : 一番大きい資料型、数字の後ろに L or l -> 16L

  - 文字型
    1. char (2byte) : JavaはUnicode UTF-16を使用する。整数型intに変換して保存する

  - 実数型
    1. float (4byte) : float型を使うときは後ろにF, fを　付ける。
    2. double (8byte) : javaの基本実数型

  - 論理型
    1. boolean (1byte) : true or false;

  - 資料型なしに変数使用(java 10)
    - 資料型が必要な利用としては変数を宣言する時使用するメモリの大きさとタイプを区別するために使用
    - 地域変数タイプ推論(Local Variable Type Inference)　→　変数に体入する値を見てcompilerが推論して決める。


- 定数(constant)
  - 変化しない値
  - Javaでの定数の宣言 -> finalを使う -> goやjavascriptみたいにconst型がない
  - 定数の場合大文字で宣言するのがコンベンション(convention)


- Literal
  - Promgramで使われる全ての数字、値、論理値...
  - literalに当たる値は特定のメモリ空間に保存されている(constant pool)
  - 必要な場合constant poolから持ってきて使う
  - constant poolに保存される時整数はint型、実数はdoubleで保存されるのが基本ルール
  - よってlong,floatを使う場合識別子を明示しなければならない

- 型変換(type conversion)
  - 資料型は各々使うメモリ空間の大きさと方式が違う
  - 黙示的型変換(Implicit Conversion)
    - 小さい値から大きい値に、やや精密度が低いからもっと精密な値に体入される時
    - ex) `long num = 3; 3` <- literalとして基本int型
  - 明示的型変換(Explicit Conversion)
    - 黙示的型変換の反対
    - 変換される型を明示する必要がある、
    - 値の損失があり得る。

## Operator(演算子)
  - Operand(被演算子・항) : 演算に使用される値。
  - Operator(演算子・연산자) : 被演算子を利用して演算する記号
    - 単項演算子 : ```++num```
    - 二項演算子 : ```num1 + num2;```
    - 三項演算子 : ```(5>3) ? 1 : 0;```

  ### 代入演算子
  - 変数に値を代入する演算子
   - 優先順位が一番低い演算子
    

  ### 算術演算子
  - 四則演算に使われる
  - `+ - * / % `

  ### 増加減少演算子
  - `++`  被演算子の値に１を足す
    - `val = ++num;`
      - 先にnumの値が増加した後valに代入される。
      - -> ;(semi colon)が付けられる前に足せという意味;
    - `val = num++;`
      - valに既存のnumの値を代入した後numの値を増加させる
  - `--`  被演算子の値から１を引く

  ### 関係演算子
  - 二項演算し
    - 演算の結果がtrue、falseどちらかで変換される。
    - 左被演算子が基準
    - `>` ->  `num>3` : true
    - `<` ->  `num<3` : true
    - `>=` ->  `num>=3` : true
    - `<=` ->  `num<=3` : true
    - `==` ->  `num==3` : true
    - `!=` ->  `num!=3` : true

  ### 論理演算子
  - 関係演算子と交わってよく使われる
  - 演算の結果がtrue or falseどちらかで変換される。
  - `&&` 論理積：両被演算子がtrueの場合trueを返すそうでは無い場合false　`bool bVal = (5 > 3) && (5 > 2)` : true;
  - `||` 論理和：両被演算子の内一つだけtrueであればtrueを返す `bool bVal = (5 > 3) || (5 < 2)` : true;
  - `!` 単行演算子である、否定 trueはfalse、falseはtrue `bool bVal = !(5 > 3)` : false;
  - 短絡回廊評価(Short Circuit Evaluation)
    - 論理積(&&)は両被演算子が全てtrueの場合結果がtrueになる
      - &rarr; 前の被演算子がfalseであれば後ろの被演算子を評価しなくてもfalseである。
    - 論理和(||)は両被演算子が全てfalseの時結果がfalseになる
      - &rarr; 前の被演算子がtrueであれば後ろの被演算子を評価しなくてもtrueである。

  ### 複合代入演算子
  - 代入演算子と他の演算子を一緒に使う。
  - 実際のコーディングでよく使われる。

    - `+=`: 二つの被演算子の値を足して左の被演算子に代入 `num += 2;` == `num1 = num1 + 2;`
    - `-=`: 左の被演算子から右の被演算子の値を引いてそれを左の被演算子に足す `num -= 2;`
    - `*=`: 二つの値を掛けてその値を左被演算子に代入 `num *= 2;`
    - `/=`: ...
    - `%=`: ...

    ビット演算子との複合演算子
    - `<<=`: 
    - `>>=`: 
    - `>>>=`: 
    - `&=`: 
    - `!=`: 
    - `^=`: 

  ### 条件演算子
  - 三項演算子
    - 条件式の結果がtrueの場合とfalseの場合によって他の式や結果が実行される。
      `(5 > 3) ? trueSomething() : falseSomething();`


  ### ビット演算子
  - ビット演算子は整数のみ適用可能
    - `~`: ビットの反転（１の補数） `a = ~a`;
    - `&`: ビット単位AND 1&1 -> 1 その以外は0
    - `|`: ビット単位OR 0|0 -> 0 その以外は1
    - `^`: ビット単位XOR 二つのビットが違う場合1を返す一緒の時は0
    - `<<`: 左シフト `a << 2` 変数aを2ビット左にシフトさせる。
    - `>>`: 右シフト `a >> 2` 変数aを2ビット左にシフトさせる。

## 制御
  ### 条件分
  - `if~else`
    - 与えられた条件に基づいて違うコードが実行されるようにプログラミングする事。
    - 条件がtrueであれば条件分の処理を終了して外のコードに移る。
      - `if ~ else`
      - `if ~ else if ~ else`
  - `switch~case`
    - 条件式の結果が整数または文字列の値でその値によって実行文が決められる時switch-case文を使う
    - Java7からcaseの値に文字列を使用可能になりました。
      `String medal = "Gold" switch(medal) case "Gold": System.out.println("金メダルです。");`
    - 条件が同じ場合同一のラインでかける
      ```
          switch(month)
                case1 : case3: case5: case7:
                    day 31
                    break;
      ```
  ### 反復文
  - 与えられた条件が満足するまでに実行文が反復的に実行される。
    `while, do-while, for`文等がある。
    - `while`
      条件分がtrueの間反復的に実行される。
    - `do-while`
      do中の実行文を実行してから条件式をチェックする。
      実行文が絶対一回は実行されるべきの場合使用される。
    - `for`
      主に条件が回数の時使われる。

  ### continue & break
  - `continue`文
    - 反復文と一緒に使われる、反復文内部で`continue`を会うと以後反復されるコードは実行されずに条件式や増減式を実行する。
  - `break`文
    - 反復文で`break`を会うと反復文を実行せずに反復文から抜ける、
    - 重ねている反復文の内部にある場合一番近い反復文一個だけを抜けられる。


  ## オブジェクト指向プログラミングとクラス
  - オブジェクトとは？
    - 意思や行為の影響が当たる対象　ー　辞書的
    - 具体的、抽象的データの単位

  - オブジェクト指向プログラミング(Object Oriented Programming, OOP)
    - オブジェクトを基盤とするプログラミング
      cf. 절차 프로그래밍(Procedural Programming, C言語)

    - クラスとは？
      - オブジェクトに対す属性と機能をコードで実現した物
      - クラスを定義するという
      - オブジェクトに対すblueprint
      - クラスは頭文字は大文字
      - 一つのjavaファイルの中に一つのクラスを置くのが原則だがいくつかのクラスが一緒にある場合
        publicクラスは一つであり、publicクラスとjavaファイルの名前は一緒でなけらばならない。
      - javaの全てのコードはclassのなかに存在する。

    - オブジェクトの属性
      - オブジェクトの特性、属性、メンバー変数
      - property, attribute, member variable
    - オブジェクトの機能
      - オブジェクトがする機能等をメソッドで実現
      - method, member function

    - メソッドとは？
      - 関数の一種
        - オブジェクトの機能を提供するためにクラスの内部に実現する関数
      - 関数とは？
        - 一つの機能を実行する一連のコード
          重複する機能を関数で実現して関数を呼び出して使う。
      - 関数とスタックメモリ
        - 関数が呼び出される時使用されるメモリ - Stack
        - 関数の機能の実行が終わると自動で変換されるメモリ

    - クラスとインスタンス(実例)
      - クラス(staticコード) - 生成(インスタンス化) -> インスタンス(dynamic memory)
      - クラスの生成
        - クラスを使用するためにはクラスを生成しなければならない
        - new予約後を使いクラスを生成
        - クラス型　変数名 = new 生成者;
        - `Student studentA = new Student();`
        - studentA <- 参照変数(reference variable)
        - Student <- Object Type
      - インスタンスとヒップメモリ(heap memory)
        - クラスがインスタンスに生成された状態
        - 一つのクラスコードからいくつかのインスタンスを生成
        - インスタンスはheap memory上に生成される。
        - 個々のインスタンスは異なるメモリに異なる値を持つ。
        - 参照変数(reference variable)
        - 参照値(reference value)
      - コンストラクター(constructor)
        - コンストラクターの名前はそのクラスの名前と一緒
        - コンストラクターはメソッドでは無い、継承されない、return値は無い
        - コンストラクターは変換タイプが無い。
        - インスタンス生成時newキーワードと一緒に使われた生成者
        - javaクラス内にコンストラクターが一つもない場合はJVMが自動的に生成してくれる　→ default constructor
        - `public Student() {}` <- parameterがない、コードもない
        - constructorは呼び出されたインスタンス→オブジェクトが生成される時持って欲しいな物を書く
        - constructor overloading -> 名前が全く同じのコンストラクターでparameterが違う場合overloadingが起こる
        - ```
            public Student() {}
            public Student(int num, String name) {}
          ```

    ### 参照資料型(reference data type)
    - 変数の資料型 - 基本資料型 : `int, long, float, double...`
                 |
                 - 参照資料型 : `String, Date, Student...`
    - 情報隠匿(いんとく:은닉)（隠す）(information hiding)
      - private: 接近制御子(access modifier)
        - クラスの外部からクラスの内部のメンバ変数やメソッドに接近(access)出来ないようにする。
        - メンバ変数やメソッドを外部から使用できないようにしてエラーを減らすことが出来る
        - 変数に対しては必要の場合get(),set()メソッドを提供
      - 接近制御子に何も無い場合: defalut => 同じパッケージ内ではaccess可能。

    ### this
    - 自分のメモリを指す
      - 生成されたインスタンスを自ら指す予約語
      - heapメモリ上に生成されたインスタンスを指す。
    - 生成者で他の生成者を呼び出す
    - 自分のアドレスを返す

    ### static変数(予約語)
    - static変数の定義と使用方法
      - いくつかのインスタンスが同じメモリ値を共有する為に使用。
    - stackでも無いheapでも無い他のメモリを使用する。→ static areaに保存する。
    - static変数はインスタンスが生成される度に違うメモリを持つのではなくプログラムがメモリに積載される時(load)データ領域のメモリに生成される。
    - インスタンスの生成と関係なしにクラスの名前で直接参照する。
    - クラス変数とも呼ぶ
    - メンバー変数はインスタンス変数とも呼ぶ。
    
    ### staticメソッド
    - クラスメソッドとも呼ぶ
    - staticメソッド中ではインスタンス変数(メンバー変数)を使うことが出来ない
    - インスタンス変数の場合絶対にインスタンスが先に生成されなければならないのでstaticメソッドでは生成が不確実なインスタンス変数を使うことはいけない。

  ## Singletone pattern
  - staticの応用
  - システムの中に単一のインスタンスだけが存在するように実装する方式
  - androidでも使われている

  ## 配列と ArrayList
  - 基本資料型配列
  - 整数２０個を利用するプルグラムを作るとき整数タイプの変数を２０個宣言しなければならない。
  - 非効率的で変数管理も難しい。
  - 配列を使うと同一の資料型の変数を一期に順次的で管理できる。
  - 配列はFixed lengthで始まる→作る時lengthを指定するから。
  - 連続する資料型中間が抜いちゃ駄目
  - type[] arrayName = new type[length] -> `int[] arr = new int[10]`
  - type arrayNamep[] = new type[length] -> `int arr[] = new int[10]`
  - 配列の初期化 宣言と同時に初期化できる。　→　配列を初期化するときは配列の長さを明示しない。
  - `int[] studentIds = new int[] {101, 102, 103}`
  - 初期化しなかった場合 int 0, double 0.0, オブジェクト配列は nullになる。
    ### 配列複製  
    - 既存の配列と同じ配列を作ったり配列がいっぱいになった場合もっと大きい配列を作りため使われる。
    - `System.arraycopy(src,srcPos,dest,destPos,length);`
      - `src` 複製する配列の名前
      - `srcPos` 複製する配列の初めの位置
      - `dest`  複製して入れる対象の配列名前
      - `destPos` 複製して入れる対象配列の初めの位置
      - `length` srcからdestに資料を複製する要素の個数
    ### オブジェクト配列
    - 参照資料型を宣言するオブジェクト配列
    - 配列だけ生成した場合要素はnullで初期化される。-> 各インスタンスは生成されてなくてmemory addressだけ確保した段階
    - 各要素をnewを活用して生成して保存しなければならない。
      #### オブジェクト型配列の複製
      - 浅い複製：配列要素のアドレスだけが複製されるので配列の要素が変更されると複製された配列の値も変更される。
      - オブジェクト型配列の深い複製
  

  ### ETC
  - `%s` : string, `%n` : line alignment